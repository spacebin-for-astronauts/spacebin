// Code generated by counterfeiter. DO NOT EDIT.
package databasefakes

import (
	"context"
	"sync"

	"github.com/lukewhrit/spacebin/internal/database"
)

type FakeDatabase struct {
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	CreateAccountStub        func(context.Context, string, string) error
	createAccountMutex       sync.RWMutex
	createAccountArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	createAccountReturns struct {
		result1 error
	}
	createAccountReturnsOnCall map[int]struct {
		result1 error
	}
	CreateDocumentStub        func(context.Context, string, string) error
	createDocumentMutex       sync.RWMutex
	createDocumentArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	createDocumentReturns struct {
		result1 error
	}
	createDocumentReturnsOnCall map[int]struct {
		result1 error
	}
	CreateSessionStub        func(context.Context, string, string, string) error
	createSessionMutex       sync.RWMutex
	createSessionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	createSessionReturns struct {
		result1 error
	}
	createSessionReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteAccountStub        func(context.Context, string) error
	deleteAccountMutex       sync.RWMutex
	deleteAccountArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteAccountReturns struct {
		result1 error
	}
	deleteAccountReturnsOnCall map[int]struct {
		result1 error
	}
	GetAccountStub        func(context.Context, string) (database.Account, error)
	getAccountMutex       sync.RWMutex
	getAccountArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getAccountReturns struct {
		result1 database.Account
		result2 error
	}
	getAccountReturnsOnCall map[int]struct {
		result1 database.Account
		result2 error
	}
	GetAccountByUsernameStub        func(context.Context, string) (database.Account, error)
	getAccountByUsernameMutex       sync.RWMutex
	getAccountByUsernameArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getAccountByUsernameReturns struct {
		result1 database.Account
		result2 error
	}
	getAccountByUsernameReturnsOnCall map[int]struct {
		result1 database.Account
		result2 error
	}
	GetDocumentStub        func(context.Context, string) (database.Document, error)
	getDocumentMutex       sync.RWMutex
	getDocumentArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getDocumentReturns struct {
		result1 database.Document
		result2 error
	}
	getDocumentReturnsOnCall map[int]struct {
		result1 database.Document
		result2 error
	}
	GetSessionStub        func(context.Context, string) (database.Session, error)
	getSessionMutex       sync.RWMutex
	getSessionArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getSessionReturns struct {
		result1 database.Session
		result2 error
	}
	getSessionReturnsOnCall map[int]struct {
		result1 database.Session
		result2 error
	}
	MigrateStub        func(context.Context) error
	migrateMutex       sync.RWMutex
	migrateArgsForCall []struct {
		arg1 context.Context
	}
	migrateReturns struct {
		result1 error
	}
	migrateReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDatabase) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabase) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeDatabase) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeDatabase) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) CreateAccount(arg1 context.Context, arg2 string, arg3 string) error {
	fake.createAccountMutex.Lock()
	ret, specificReturn := fake.createAccountReturnsOnCall[len(fake.createAccountArgsForCall)]
	fake.createAccountArgsForCall = append(fake.createAccountArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateAccountStub
	fakeReturns := fake.createAccountReturns
	fake.recordInvocation("CreateAccount", []interface{}{arg1, arg2, arg3})
	fake.createAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabase) CreateAccountCallCount() int {
	fake.createAccountMutex.RLock()
	defer fake.createAccountMutex.RUnlock()
	return len(fake.createAccountArgsForCall)
}

func (fake *FakeDatabase) CreateAccountCalls(stub func(context.Context, string, string) error) {
	fake.createAccountMutex.Lock()
	defer fake.createAccountMutex.Unlock()
	fake.CreateAccountStub = stub
}

func (fake *FakeDatabase) CreateAccountArgsForCall(i int) (context.Context, string, string) {
	fake.createAccountMutex.RLock()
	defer fake.createAccountMutex.RUnlock()
	argsForCall := fake.createAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDatabase) CreateAccountReturns(result1 error) {
	fake.createAccountMutex.Lock()
	defer fake.createAccountMutex.Unlock()
	fake.CreateAccountStub = nil
	fake.createAccountReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) CreateAccountReturnsOnCall(i int, result1 error) {
	fake.createAccountMutex.Lock()
	defer fake.createAccountMutex.Unlock()
	fake.CreateAccountStub = nil
	if fake.createAccountReturnsOnCall == nil {
		fake.createAccountReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createAccountReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) CreateDocument(arg1 context.Context, arg2 string, arg3 string) error {
	fake.createDocumentMutex.Lock()
	ret, specificReturn := fake.createDocumentReturnsOnCall[len(fake.createDocumentArgsForCall)]
	fake.createDocumentArgsForCall = append(fake.createDocumentArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateDocumentStub
	fakeReturns := fake.createDocumentReturns
	fake.recordInvocation("CreateDocument", []interface{}{arg1, arg2, arg3})
	fake.createDocumentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabase) CreateDocumentCallCount() int {
	fake.createDocumentMutex.RLock()
	defer fake.createDocumentMutex.RUnlock()
	return len(fake.createDocumentArgsForCall)
}

func (fake *FakeDatabase) CreateDocumentCalls(stub func(context.Context, string, string) error) {
	fake.createDocumentMutex.Lock()
	defer fake.createDocumentMutex.Unlock()
	fake.CreateDocumentStub = stub
}

func (fake *FakeDatabase) CreateDocumentArgsForCall(i int) (context.Context, string, string) {
	fake.createDocumentMutex.RLock()
	defer fake.createDocumentMutex.RUnlock()
	argsForCall := fake.createDocumentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDatabase) CreateDocumentReturns(result1 error) {
	fake.createDocumentMutex.Lock()
	defer fake.createDocumentMutex.Unlock()
	fake.CreateDocumentStub = nil
	fake.createDocumentReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) CreateDocumentReturnsOnCall(i int, result1 error) {
	fake.createDocumentMutex.Lock()
	defer fake.createDocumentMutex.Unlock()
	fake.CreateDocumentStub = nil
	if fake.createDocumentReturnsOnCall == nil {
		fake.createDocumentReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createDocumentReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) CreateSession(arg1 context.Context, arg2 string, arg3 string, arg4 string) error {
	fake.createSessionMutex.Lock()
	ret, specificReturn := fake.createSessionReturnsOnCall[len(fake.createSessionArgsForCall)]
	fake.createSessionArgsForCall = append(fake.createSessionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.CreateSessionStub
	fakeReturns := fake.createSessionReturns
	fake.recordInvocation("CreateSession", []interface{}{arg1, arg2, arg3, arg4})
	fake.createSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabase) CreateSessionCallCount() int {
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	return len(fake.createSessionArgsForCall)
}

func (fake *FakeDatabase) CreateSessionCalls(stub func(context.Context, string, string, string) error) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = stub
}

func (fake *FakeDatabase) CreateSessionArgsForCall(i int) (context.Context, string, string, string) {
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	argsForCall := fake.createSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeDatabase) CreateSessionReturns(result1 error) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = nil
	fake.createSessionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) CreateSessionReturnsOnCall(i int, result1 error) {
	fake.createSessionMutex.Lock()
	defer fake.createSessionMutex.Unlock()
	fake.CreateSessionStub = nil
	if fake.createSessionReturnsOnCall == nil {
		fake.createSessionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createSessionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) DeleteAccount(arg1 context.Context, arg2 string) error {
	fake.deleteAccountMutex.Lock()
	ret, specificReturn := fake.deleteAccountReturnsOnCall[len(fake.deleteAccountArgsForCall)]
	fake.deleteAccountArgsForCall = append(fake.deleteAccountArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteAccountStub
	fakeReturns := fake.deleteAccountReturns
	fake.recordInvocation("DeleteAccount", []interface{}{arg1, arg2})
	fake.deleteAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabase) DeleteAccountCallCount() int {
	fake.deleteAccountMutex.RLock()
	defer fake.deleteAccountMutex.RUnlock()
	return len(fake.deleteAccountArgsForCall)
}

func (fake *FakeDatabase) DeleteAccountCalls(stub func(context.Context, string) error) {
	fake.deleteAccountMutex.Lock()
	defer fake.deleteAccountMutex.Unlock()
	fake.DeleteAccountStub = stub
}

func (fake *FakeDatabase) DeleteAccountArgsForCall(i int) (context.Context, string) {
	fake.deleteAccountMutex.RLock()
	defer fake.deleteAccountMutex.RUnlock()
	argsForCall := fake.deleteAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDatabase) DeleteAccountReturns(result1 error) {
	fake.deleteAccountMutex.Lock()
	defer fake.deleteAccountMutex.Unlock()
	fake.DeleteAccountStub = nil
	fake.deleteAccountReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) DeleteAccountReturnsOnCall(i int, result1 error) {
	fake.deleteAccountMutex.Lock()
	defer fake.deleteAccountMutex.Unlock()
	fake.DeleteAccountStub = nil
	if fake.deleteAccountReturnsOnCall == nil {
		fake.deleteAccountReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAccountReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) GetAccount(arg1 context.Context, arg2 string) (database.Account, error) {
	fake.getAccountMutex.Lock()
	ret, specificReturn := fake.getAccountReturnsOnCall[len(fake.getAccountArgsForCall)]
	fake.getAccountArgsForCall = append(fake.getAccountArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetAccountStub
	fakeReturns := fake.getAccountReturns
	fake.recordInvocation("GetAccount", []interface{}{arg1, arg2})
	fake.getAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabase) GetAccountCallCount() int {
	fake.getAccountMutex.RLock()
	defer fake.getAccountMutex.RUnlock()
	return len(fake.getAccountArgsForCall)
}

func (fake *FakeDatabase) GetAccountCalls(stub func(context.Context, string) (database.Account, error)) {
	fake.getAccountMutex.Lock()
	defer fake.getAccountMutex.Unlock()
	fake.GetAccountStub = stub
}

func (fake *FakeDatabase) GetAccountArgsForCall(i int) (context.Context, string) {
	fake.getAccountMutex.RLock()
	defer fake.getAccountMutex.RUnlock()
	argsForCall := fake.getAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDatabase) GetAccountReturns(result1 database.Account, result2 error) {
	fake.getAccountMutex.Lock()
	defer fake.getAccountMutex.Unlock()
	fake.GetAccountStub = nil
	fake.getAccountReturns = struct {
		result1 database.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) GetAccountReturnsOnCall(i int, result1 database.Account, result2 error) {
	fake.getAccountMutex.Lock()
	defer fake.getAccountMutex.Unlock()
	fake.GetAccountStub = nil
	if fake.getAccountReturnsOnCall == nil {
		fake.getAccountReturnsOnCall = make(map[int]struct {
			result1 database.Account
			result2 error
		})
	}
	fake.getAccountReturnsOnCall[i] = struct {
		result1 database.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) GetAccountByUsername(arg1 context.Context, arg2 string) (database.Account, error) {
	fake.getAccountByUsernameMutex.Lock()
	ret, specificReturn := fake.getAccountByUsernameReturnsOnCall[len(fake.getAccountByUsernameArgsForCall)]
	fake.getAccountByUsernameArgsForCall = append(fake.getAccountByUsernameArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetAccountByUsernameStub
	fakeReturns := fake.getAccountByUsernameReturns
	fake.recordInvocation("GetAccountByUsername", []interface{}{arg1, arg2})
	fake.getAccountByUsernameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabase) GetAccountByUsernameCallCount() int {
	fake.getAccountByUsernameMutex.RLock()
	defer fake.getAccountByUsernameMutex.RUnlock()
	return len(fake.getAccountByUsernameArgsForCall)
}

func (fake *FakeDatabase) GetAccountByUsernameCalls(stub func(context.Context, string) (database.Account, error)) {
	fake.getAccountByUsernameMutex.Lock()
	defer fake.getAccountByUsernameMutex.Unlock()
	fake.GetAccountByUsernameStub = stub
}

func (fake *FakeDatabase) GetAccountByUsernameArgsForCall(i int) (context.Context, string) {
	fake.getAccountByUsernameMutex.RLock()
	defer fake.getAccountByUsernameMutex.RUnlock()
	argsForCall := fake.getAccountByUsernameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDatabase) GetAccountByUsernameReturns(result1 database.Account, result2 error) {
	fake.getAccountByUsernameMutex.Lock()
	defer fake.getAccountByUsernameMutex.Unlock()
	fake.GetAccountByUsernameStub = nil
	fake.getAccountByUsernameReturns = struct {
		result1 database.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) GetAccountByUsernameReturnsOnCall(i int, result1 database.Account, result2 error) {
	fake.getAccountByUsernameMutex.Lock()
	defer fake.getAccountByUsernameMutex.Unlock()
	fake.GetAccountByUsernameStub = nil
	if fake.getAccountByUsernameReturnsOnCall == nil {
		fake.getAccountByUsernameReturnsOnCall = make(map[int]struct {
			result1 database.Account
			result2 error
		})
	}
	fake.getAccountByUsernameReturnsOnCall[i] = struct {
		result1 database.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) GetDocument(arg1 context.Context, arg2 string) (database.Document, error) {
	fake.getDocumentMutex.Lock()
	ret, specificReturn := fake.getDocumentReturnsOnCall[len(fake.getDocumentArgsForCall)]
	fake.getDocumentArgsForCall = append(fake.getDocumentArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetDocumentStub
	fakeReturns := fake.getDocumentReturns
	fake.recordInvocation("GetDocument", []interface{}{arg1, arg2})
	fake.getDocumentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabase) GetDocumentCallCount() int {
	fake.getDocumentMutex.RLock()
	defer fake.getDocumentMutex.RUnlock()
	return len(fake.getDocumentArgsForCall)
}

func (fake *FakeDatabase) GetDocumentCalls(stub func(context.Context, string) (database.Document, error)) {
	fake.getDocumentMutex.Lock()
	defer fake.getDocumentMutex.Unlock()
	fake.GetDocumentStub = stub
}

func (fake *FakeDatabase) GetDocumentArgsForCall(i int) (context.Context, string) {
	fake.getDocumentMutex.RLock()
	defer fake.getDocumentMutex.RUnlock()
	argsForCall := fake.getDocumentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDatabase) GetDocumentReturns(result1 database.Document, result2 error) {
	fake.getDocumentMutex.Lock()
	defer fake.getDocumentMutex.Unlock()
	fake.GetDocumentStub = nil
	fake.getDocumentReturns = struct {
		result1 database.Document
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) GetDocumentReturnsOnCall(i int, result1 database.Document, result2 error) {
	fake.getDocumentMutex.Lock()
	defer fake.getDocumentMutex.Unlock()
	fake.GetDocumentStub = nil
	if fake.getDocumentReturnsOnCall == nil {
		fake.getDocumentReturnsOnCall = make(map[int]struct {
			result1 database.Document
			result2 error
		})
	}
	fake.getDocumentReturnsOnCall[i] = struct {
		result1 database.Document
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) GetSession(arg1 context.Context, arg2 string) (database.Session, error) {
	fake.getSessionMutex.Lock()
	ret, specificReturn := fake.getSessionReturnsOnCall[len(fake.getSessionArgsForCall)]
	fake.getSessionArgsForCall = append(fake.getSessionArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetSessionStub
	fakeReturns := fake.getSessionReturns
	fake.recordInvocation("GetSession", []interface{}{arg1, arg2})
	fake.getSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDatabase) GetSessionCallCount() int {
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	return len(fake.getSessionArgsForCall)
}

func (fake *FakeDatabase) GetSessionCalls(stub func(context.Context, string) (database.Session, error)) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = stub
}

func (fake *FakeDatabase) GetSessionArgsForCall(i int) (context.Context, string) {
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	argsForCall := fake.getSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDatabase) GetSessionReturns(result1 database.Session, result2 error) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = nil
	fake.getSessionReturns = struct {
		result1 database.Session
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) GetSessionReturnsOnCall(i int, result1 database.Session, result2 error) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = nil
	if fake.getSessionReturnsOnCall == nil {
		fake.getSessionReturnsOnCall = make(map[int]struct {
			result1 database.Session
			result2 error
		})
	}
	fake.getSessionReturnsOnCall[i] = struct {
		result1 database.Session
		result2 error
	}{result1, result2}
}

func (fake *FakeDatabase) Migrate(arg1 context.Context) error {
	fake.migrateMutex.Lock()
	ret, specificReturn := fake.migrateReturnsOnCall[len(fake.migrateArgsForCall)]
	fake.migrateArgsForCall = append(fake.migrateArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.MigrateStub
	fakeReturns := fake.migrateReturns
	fake.recordInvocation("Migrate", []interface{}{arg1})
	fake.migrateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDatabase) MigrateCallCount() int {
	fake.migrateMutex.RLock()
	defer fake.migrateMutex.RUnlock()
	return len(fake.migrateArgsForCall)
}

func (fake *FakeDatabase) MigrateCalls(stub func(context.Context) error) {
	fake.migrateMutex.Lock()
	defer fake.migrateMutex.Unlock()
	fake.MigrateStub = stub
}

func (fake *FakeDatabase) MigrateArgsForCall(i int) context.Context {
	fake.migrateMutex.RLock()
	defer fake.migrateMutex.RUnlock()
	argsForCall := fake.migrateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDatabase) MigrateReturns(result1 error) {
	fake.migrateMutex.Lock()
	defer fake.migrateMutex.Unlock()
	fake.MigrateStub = nil
	fake.migrateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) MigrateReturnsOnCall(i int, result1 error) {
	fake.migrateMutex.Lock()
	defer fake.migrateMutex.Unlock()
	fake.MigrateStub = nil
	if fake.migrateReturnsOnCall == nil {
		fake.migrateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.migrateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDatabase) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.createAccountMutex.RLock()
	defer fake.createAccountMutex.RUnlock()
	fake.createDocumentMutex.RLock()
	defer fake.createDocumentMutex.RUnlock()
	fake.createSessionMutex.RLock()
	defer fake.createSessionMutex.RUnlock()
	fake.deleteAccountMutex.RLock()
	defer fake.deleteAccountMutex.RUnlock()
	fake.getAccountMutex.RLock()
	defer fake.getAccountMutex.RUnlock()
	fake.getAccountByUsernameMutex.RLock()
	defer fake.getAccountByUsernameMutex.RUnlock()
	fake.getDocumentMutex.RLock()
	defer fake.getDocumentMutex.RUnlock()
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	fake.migrateMutex.RLock()
	defer fake.migrateMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDatabase) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ database.Database = new(FakeDatabase)
